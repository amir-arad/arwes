import { test, expect, beforeEach } from 'vitest'

import { type MoveTimeTo, setupTimers, createMoveTimeTo } from '../../__testUtils__/timers'
import { createAnimatorInterface } from '../../__testUtils__/nodes'

setupTimers()

let moveTimeTo: MoveTimeTo

beforeEach(() => {
  moveTimeTo = createMoveTimeTo()
})

test('Should create parent and transition children', async () => {
  const parent = createAnimatorInterface(undefined, { manager: 'sequence' })
  const child1 = createAnimatorInterface(parent)
  const child2 = createAnimatorInterface(parent)
  const child3 = createAnimatorInterface(parent)
  queueMicrotask(() => child3.node.send('setup'))
  queueMicrotask(() => child2.node.send('setup'))
  queueMicrotask(() => child1.node.send('setup'))
  queueMicrotask(() => parent.node.send('setup'))

  expect(parent.node.state).toBe('exited')
  expect(child1.node.state).toBe('exited')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(0.001)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('exited')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(0.399)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('exited')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(0.401)
  expect(parent.node.state).toBe('entered')
  expect(child1.node.state).toBe('entering')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(0.799)
  expect(parent.node.state).toBe('entered')
  expect(child1.node.state).toBe('entering')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(0.801)
  expect(parent.node.state).toBe('entered')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entering')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(1.199)
  expect(parent.node.state).toBe('entered')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entering')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(1.201)
  expect(parent.node.state).toBe('entered')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entering')
  moveTimeTo(1.599)
  expect(parent.node.state).toBe('entered')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entering')
  moveTimeTo(1.601)
  expect(parent.node.state).toBe('entered')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entered')
  moveTimeTo(2)
  expect(parent.node.state).toBe('entered')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entered')
})

test('Should create combined parent and transition children', async () => {
  const parent = createAnimatorInterface(undefined, { combine: true, manager: 'sequence' })
  const child1 = createAnimatorInterface(parent)
  const child2 = createAnimatorInterface(parent)
  const child3 = createAnimatorInterface(parent)
  queueMicrotask(() => child3.node.send('setup'))
  queueMicrotask(() => child2.node.send('setup'))
  queueMicrotask(() => child1.node.send('setup'))
  queueMicrotask(() => parent.node.send('setup'))

  expect(parent.node.state).toBe('exited')
  expect(child1.node.state).toBe('exited')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(0.001)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entering')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(0.399)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entering')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(0.401)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entering')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(0.799)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entering')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(0.801)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entering')
  moveTimeTo(1.199)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entering')
  moveTimeTo(1.201)
  expect(parent.node.state).toBe('entered')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entered')
  moveTimeTo(2)
  expect(parent.node.state).toBe('entered')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entered')
})

test('Should create combined parent sequenceReverse and transition children', async () => {
  const parent = createAnimatorInterface(undefined, { combine: true, manager: 'sequenceReverse' })
  const child1 = createAnimatorInterface(parent)
  const child2 = createAnimatorInterface(parent)
  const child3 = createAnimatorInterface(parent)
  queueMicrotask(() => child3.node.send('setup'))
  queueMicrotask(() => child2.node.send('setup'))
  queueMicrotask(() => child1.node.send('setup'))
  queueMicrotask(() => parent.node.send('setup'))

  expect(parent.node.state).toBe('exited')
  expect(child1.node.state).toBe('exited')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(0.001)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('exited')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('entering')
  moveTimeTo(0.399)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('exited')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('entering')
  moveTimeTo(0.401)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('exited')
  expect(child2.node.state).toBe('entering')
  expect(child3.node.state).toBe('entered')
  moveTimeTo(0.799)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('exited')
  expect(child2.node.state).toBe('entering')
  expect(child3.node.state).toBe('entered')
  moveTimeTo(0.801)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entering')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entered')
  moveTimeTo(1.199)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entering')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entered')
  moveTimeTo(1.201)
  expect(parent.node.state).toBe('entered')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entered')
  moveTimeTo(2)
  expect(parent.node.state).toBe('entered')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entered')
})

test('Should create combined parent and transition children with custom durations', async () => {
  const parent = createAnimatorInterface(undefined, { combine: true, manager: 'sequence' })
  const child1 = createAnimatorInterface(parent, { duration: { enter: 0.2 } })
  const child2 = createAnimatorInterface(parent, { duration: { offset: 0.1 } })
  const child3 = createAnimatorInterface(parent, { duration: { enter: 0.1, delay: 0.2 } })
  const child4 = createAnimatorInterface(parent, { duration: { enter: 0.05 } })
  queueMicrotask(() => child4.node.send('setup'))
  queueMicrotask(() => child3.node.send('setup'))
  queueMicrotask(() => child2.node.send('setup'))
  queueMicrotask(() => child1.node.send('setup'))
  queueMicrotask(() => parent.node.send('setup'))

  expect(parent.node.state).toBe('exited')
  expect(child1.node.state).toBe('exited')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')
  expect(child4.node.state).toBe('exited')
  moveTimeTo(0.001)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entering') // Enters with parent
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')
  expect(child4.node.state).toBe('exited')
  moveTimeTo(0.199)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entering')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')
  expect(child4.node.state).toBe('exited')
  moveTimeTo(0.201)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('exited') // offset = 0.1
  expect(child3.node.state).toBe('exited')
  expect(child4.node.state).toBe('exited')
  moveTimeTo(0.299)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')
  expect(child4.node.state).toBe('exited')
  moveTimeTo(0.301)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entering') // 0.2 + (offset=0.1) = 0.3
  expect(child3.node.state).toBe('exited')
  expect(child4.node.state).toBe('exited')
  moveTimeTo(0.699)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entering')
  expect(child3.node.state).toBe('exited')
  expect(child4.node.state).toBe('exited')
  moveTimeTo(0.701)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('exited') // delay = 0.2
  expect(child4.node.state).toBe('exited')
  moveTimeTo(0.799)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('exited')
  expect(child4.node.state).toBe('exited')
  moveTimeTo(0.801)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('exited')
  expect(child4.node.state).toBe('entering') // 0.2 + (offset=0.1) + 0.4 + 0.1 = 0.8
  moveTimeTo(0.849)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('exited')
  expect(child4.node.state).toBe('entering')
  moveTimeTo(0.851)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('exited')
  expect(child4.node.state).toBe('entered')
  moveTimeTo(0.898)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('exited')
  expect(child4.node.state).toBe('entered')
  moveTimeTo(0.901)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entering') // 0.2 + (offset=0.1) + 0.4 + 0.2 = 0.9
  expect(child4.node.state).toBe('entered')
  moveTimeTo(0.998)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entering')
  expect(child4.node.state).toBe('entered')
  moveTimeTo(1.001)
  expect(parent.node.state).toBe('entered')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entered')
  expect(child4.node.state).toBe('entered')
  moveTimeTo(2)
  expect(parent.node.state).toBe('entered')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entered')
  expect(child4.node.state).toBe('entered')
})
