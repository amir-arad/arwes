import { test, expect, beforeEach } from 'vitest'

import { type MoveTimeTo, setupTimers, createMoveTimeTo } from '../../__testUtils__/timers'
import { createAnimatorInterface } from '../../__testUtils__/nodes'

setupTimers()

let moveTimeTo: MoveTimeTo

beforeEach(() => {
  moveTimeTo = createMoveTimeTo()
})

test('Should create combined parent and transition children', async () => {
  const parent = createAnimatorInterface(undefined, { combine: true, manager: 'stagger' })
  const child1 = createAnimatorInterface(parent)
  const child2 = createAnimatorInterface(parent)
  const child3 = createAnimatorInterface(parent)
  queueMicrotask(() => child3.node.send('setup'))
  queueMicrotask(() => child2.node.send('setup'))
  queueMicrotask(() => child1.node.send('setup'))
  queueMicrotask(() => parent.node.send('setup'))

  expect(parent.node.state).toBe('exited')
  expect(child1.node.state).toBe('exited')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(0)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('exited')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(0.001)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entering')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(0.039)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entering')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(0.041)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entering')
  expect(child2.node.state).toBe('entering')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(0.079)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entering')
  expect(child2.node.state).toBe('entering')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(0.081)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entering')
  expect(child2.node.state).toBe('entering')
  expect(child3.node.state).toBe('entering')
  moveTimeTo(0.399)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entering')
  expect(child2.node.state).toBe('entering')
  expect(child3.node.state).toBe('entering')
  moveTimeTo(0.401)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entering')
  expect(child3.node.state).toBe('entering')
  moveTimeTo(0.439)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entering')
  expect(child3.node.state).toBe('entering')
  moveTimeTo(0.441)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entering')
  moveTimeTo(0.479)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entering')
  moveTimeTo(0.481)
  expect(parent.node.state).toBe('entered')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entered')
  moveTimeTo(1)
  expect(parent.node.state).toBe('entered')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entered')
})

test('Should create combined node and transition children with duration delays and offsets', async () => {
  const parent = createAnimatorInterface(undefined, {
    active: false,
    combine: true,
    manager: 'stagger'
  })
  const child1 = createAnimatorInterface(parent, { duration: { enter: 0.2 } })
  const child2 = createAnimatorInterface(parent, { duration: { offset: 0.1 } })
  const child3 = createAnimatorInterface(parent, { duration: { delay: 0.05 } })
  queueMicrotask(() => child3.node.send('setup'))
  queueMicrotask(() => child2.node.send('setup'))
  queueMicrotask(() => child1.node.send('setup'))
  queueMicrotask(() => parent.node.send('setup'))

  expect(parent.node.state).toBe('exited')
  expect(child1.node.state).toBe('exited')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(1)
  expect(parent.node.state).toBe('exited')
  expect(child1.node.state).toBe('exited')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')

  parent.node.control.setDynamicSettings({ active: true })
  parent.node.send('update')

  moveTimeTo(1)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entering') // Enters at the same time as the parent
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(1.039)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entering')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(1.041)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entering')
  expect(child2.node.state).toBe('exited') // Node duration offset
  expect(child3.node.state).toBe('exited')
  moveTimeTo(1.139)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entering')
  expect(child2.node.state).toBe('exited')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(1.141)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entering')
  expect(child2.node.state).toBe('entering')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(1.179)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entering')
  expect(child2.node.state).toBe('entering')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(1.181)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entering')
  expect(child2.node.state).toBe('entering')
  expect(child3.node.state).toBe('exited') // Node duration delay
  moveTimeTo(1.199)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entering')
  expect(child2.node.state).toBe('entering')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(1.201)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entering')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(1.228)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entering')
  expect(child3.node.state).toBe('exited')
  moveTimeTo(1.231)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entering')
  expect(child3.node.state).toBe('entering')
  moveTimeTo(1.538)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entering')
  expect(child3.node.state).toBe('entering')
  moveTimeTo(1.541)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entering')
  moveTimeTo(1.628)
  expect(parent.node.state).toBe('entering')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entering')
  moveTimeTo(1.631)
  expect(parent.node.state).toBe('entered')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entered')
  moveTimeTo(3)
  expect(parent.node.state).toBe('entered')
  expect(child1.node.state).toBe('entered')
  expect(child2.node.state).toBe('entered')
  expect(child3.node.state).toBe('entered')
})
